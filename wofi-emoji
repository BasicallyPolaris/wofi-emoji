#!/bin/bash

set -euo pipefail

# Help function
show_help() {
    cat << EOF
Usage: wofi-emoji [OPTIONS]

OPTIONS:
    -l, --languages LANG1,LANG2    Specify languages to fetch (comma-separated)
                                   Available: en, de, es, fr, it, pt, ru, ja, ko, zh, etc.
                                   For full list see: https://emojibase.dev/emojis
                                   Default: en
    -f, --force                    Force refresh of cached database
    -h, --help                     Show this help message

Examples:
    wofi-emoji                     # Use English only (default)
    wofi-emoji -l en,de            # Use English and German
    wofi-emoji -l de,fr,es -f      # Use German, French, Spanish and force refresh db
EOF
}

# Default configuration
LANGUAGES="en"
FORCE_REFRESH=false

while [[ $# -gt 0 ]]; do
    case $1 in
        -l|--languages)
            LANGUAGES="$2"
            shift 2
            ;;
        -f|--force)
            FORCE_REFRESH=true
            shift
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            show_help
            exit 1
            ;;
    esac
done

# Set up cache directory
if [[ -n "${XDG_CACHE_HOME:-}" ]]; then
    CACHE_DIR="$XDG_CACHE_HOME/wofi-emoji"
else
    CACHE_DIR="$HOME/.cache/wofi-emoji"
fi

# Clean up languages (remove spaces) but preserve user order for primary language preference
CLEANED_LANGS=$(echo "$LANGUAGES" | tr ',' '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | tr '\n' ',' | sed 's/,$//')
# Create normalized version for caching (sorted for consistency)
NORMALIZED_LANGS=$(echo "$CLEANED_LANGS" | tr ',' '\n' | sort | tr '\n' ',' | sed 's/,$//')
CACHED_DB="$CACHE_DIR/emoji-database-$NORMALIZED_LANGS"

# Function to handle emoji selection and execution
handle_emoji_selection() {
    local database_file="$1"
    
    # Launch wofi emoji selector
    local selected
    selected="$(wofi -I --matching multi-contains --insensitive -p "Enter keywords ..." --show dmenu -i < "$database_file")"
    
    # Extract just the emoji if something was selected
    if [[ -n "$selected" ]]; then
        local emoji
        emoji=$(echo "$selected" | sed 's/ .*//')
        
        # Check for required tools only when we need to use them
        if command -v wtype &> /dev/null; then
            wtype "$emoji"
        else
            echo "Warning: wtype not found, cannot type emoji" >&2
        fi
        
        if command -v wl-copy &> /dev/null; then
            wl-copy "$emoji"
        else
            echo "Warning: wl-copy not found, cannot copy emoji" >&2
        fi
    fi
}

# Check if we need to refresh the cache - exit early if not needed
if [[ "$FORCE_REFRESH" != true ]] && [[ -f "$CACHED_DB" ]]; then
    # Database exists for these exact languages and no force refresh
    handle_emoji_selection "$CACHED_DB"
    exit 0
fi

# If we get here, we need to build/rebuild the database
# Check for required tools for database building
for cmd in curl jq; do
    if ! command -v "$cmd" &> /dev/null; then
        echo "Error: $cmd is required for building the database but not installed."
        exit 1
    fi
done

# Create cache directory if it doesn't exist
mkdir -p "$CACHE_DIR"

# Function to fetch emoji data for a language
fetch_language_data() {
    local lang="$1"
    local url="https://cdn.jsdelivr.net/npm/emojibase-data@latest/${lang}/data.json"
    
    if curl --fail --silent --show-error "$url"; then
        return 0
    else
        echo "Warning: Failed to fetch data for language: $lang" >&2
        return 1
    fi
}

echo "Building emoji database for languages: $NORMALIZED_LANGS..." >&2

# Convert comma-separated languages to array (preserve user order)
IFS=',' read -ra LANG_ARRAY <<< "$CLEANED_LANGS"

# Create a JSON object with all language data
LANG_DATA="{"
FIRST_LANG=true

for lang in "${LANG_ARRAY[@]}"; do
    lang=$(echo "$lang" | xargs)
    
    if [[ "$FIRST_LANG" == false ]]; then
        LANG_DATA+=","
    fi
    FIRST_LANG=false
    
    echo "Fetching $lang emoji data..." >&2
    if LANG_JSON=$(fetch_language_data "$lang"); then
        LANG_DATA+="\"$lang\":$LANG_JSON"
        echo "✓ Fetched $lang emoji data" >&2
    else
        # Remove the comma if this was not the first language and we failed
        if [[ "$LANG_DATA" == *"," ]]; then
            LANG_DATA="${LANG_DATA%,}"
        fi
    fi
done
LANG_DATA+="}"

# Process and merge the data with deduplication, preserving user language order
echo "$LANG_DATA" | jq -r --arg user_langs "$CLEANED_LANGS" '
# Store the root data and user language order
. as $all_data |
($user_langs | split(",")) as $user_order |

# Get all available language keys
keys as $available_langs |

# Create a lookup object to collect all data for each unique emoji
reduce (
    $available_langs[] as $lang |
    $all_data[$lang][] |
    select(.emoji != null and .label != null) |
    {
        emoji: .emoji,
        lang: $lang,
        label: .label,
        tags: ((.tags // []) + (.keywords // []))
    }
) as $item ({}; 
    .[$item.emoji] += [$item]
) |

# Now process each unique emoji
to_entries[] |
.key as $emoji |
.value as $emoji_data |

# Build the searchable tags string (deduplicated)
(
    $emoji_data |
    map(.tags[]) |
    unique |
    join(" ") |
    # Remove empty entries and extra spaces
    gsub("  +"; " ") | gsub("^ +| +$"; "")
) as $searchable_tags |

# Build labels string with deduplication, respecting user language order
(
    # Sort emoji_data by user preference order and deduplicate while preserving order
    reduce (
        $emoji_data |
        sort_by(
            .lang as $lang |
            ($user_order | index($lang) // 999)
        ) |
        map(.label)[]
    ) as $label ([]; 
        if (. | index($label)) == null then . + [$label] else . end
    ) |
    map("\"" + . + "\"") |
    join(" - ")
) as $labels |

# Format output: emoji "label1" - "label2" - "label3"  (tags)
$emoji +
(if $labels != "" then " " + $labels else "" end) +
# Only add parentheses if there are searchable tags
(if ($searchable_tags | length) > 0 then "  (" + $searchable_tags + ")" else "" end)
' | sort -u > "$CACHED_DB"

echo "✓ Emoji database cached successfully" >&2

# Launch wofi emoji selector
handle_emoji_selection "$CACHED_DB"
